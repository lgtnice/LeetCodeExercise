

# 哈希表

哈希表就是key-value对，解决了数组的索引只能是数字的问题，现在可以是字符串了。

哈希表的优点：快速判断 一个元素是否在集合中。

优点场景：查找 一个名字是否在某个学校中。遍历的话，不管是数组还是链表，都需要挨个进行 内存取值 ，时间复杂度为n。哈希表则不同，我们需要提前将所有名字 存储在 哈希表中，查询的时候通过索引即可知道名字是否存在于哈希表中了，时间复杂度O(1) 。

## 哈希函数

将 字符串 映射为 哈希表上的索引，这就是哈希函数。

映射完成后，就可以 **通过查询索引下标** 快速确定是否存在 某个字符串 了。

如名称所示，肯定用到了哈希算法，即摘要算法。因为 哈希表上的索引不会直接存 字符串，而是存的**字符串的哈希值**。

“你好啊” 这个是字符串，它是有编码的，而 哈希值是01001010100这样的数字，**无编码**，不同的哈希算法跟的数字指的是 摘要算法的结果有多少bit，我们经常看到的hash值只是 这种二进制数对应的**十六进制表示**。

具体参考noteforCV。

## 常见的哈希结构

数组、set、map。

set不是key-value的，只能放值。

map是key-value的。

哈希法是**牺牲了空间换取了时间**，因为我们要使用额外的 数组、set、map 来存放数据，才能实现快速的查找。

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset **依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据**，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。