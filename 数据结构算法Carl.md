刷题参考url：

[youngyangyang04/leetcode-master: 《代码随想录》LeetCode 刷题攻略：200道经典题目刷题顺序，共60w字的详细图解，视频难点剖析，50余张思维导图，支持C++，Java，Python，Go，JavaScript等多语言版本，从此算法学习不再迷茫！🔥🔥 来看看，你会发现相见恨晚！🚀 (github.com)](https://github.com/youngyangyang04/leetcode-master)



# 时间复杂度

概念一：基本操作，指在循环内完成的一系列最基础的操作，把这些操作看成一个整体。

时间复杂度的定义：循环中每个元素进行基本操作的次数，再加上O。而不是简单的看循环套了几层。

# 数组

|      | 时间复杂度 | 空间复杂度 |
| ---- | ---------- | ---------- |
| 寻址 | O(1)       |            |
| 插入 | O(n)       |            |
| 删除 | O(n)       |            |
|      |            |            |

数组是存放在连续内存空间上的相同类型数据的集合。

寻址用的技术叫下标索引

二维数组的元素在内存的空间地址连续吗？不同的编程语言的内存管理不一样，C++是连续的，而java就不连续。

C++代码：

```c++
int array[2][3] = {
		{0, 1, 2},
		{3, 4, 5}
    };
```

<img src="Pictures/数据结构算法Carl/C++二维数组.png" style="zoom:50%;" />

java：

<img src="Pictures/数据结构算法Carl/java二维数组.png" style="zoom:50%;" />

## 移除数组内的元素

快慢指针法，又叫双指针法。下面是从前到后的双指针法：

<img src="Pictures/数据结构算法Carl/从前到后的双指针法.gif"  />

## C++中的array和vector

二者都可以使用 [ ] 运算符，因为都实现了对 [] 的运算符重载。

二者的实现方式的数据存储，都使用的 数组。

Vector 可以重新构建新的不同大小的数组用来存储，但是array的数组大小初始化后便确定。

vector是容器，不是数组。

参考：https://blog.csdn.net/rusbme/article/details/97049148

## 滑动窗口

解题关键：

1.定义窗口内是什么。

2.如何移动窗口的起始位置和结束位置。

3.确定起始位置和结束位置的移动的终止条件。

## 螺旋矩阵

循环原则：在进行一个循环的时候，去寻找循环背后一定遵循的原则

# 链表

|      | 时间复杂度 | 空间复杂度 |
| ---- | ---------- | ---------- |
| 寻址 | O(n)       |            |
| 插入 | O(1)       |            |
| 删除 | O(1)       |            |
|      |            |            |

根据链表和数组的时间复杂度。数组适合数据固定、频繁查询的场景；链表适合数据不固定，频繁增删的场景。

## 虚拟头结点

使用虚拟头结点可以以一种更简洁的方法删除单链表的头部结点。

# 哈希表

哈希表就是key-value对，解决了数组的索引只能是数字的问题，现在可以是字符串了。

哈希表的优点：快速判断 一个元素是否在集合中。

优点场景：查找 一个名字是否在某个学校中。遍历的话，不管是数组还是链表，都需要挨个进行 内存取值 ，时间复杂度为n。哈希表则不同，我们需要提前将所有名字 存储在 哈希表中，查询的时候通过索引即可知道名字是否存在于哈希表中了，时间复杂度O(1) 。

## 哈希函数

将 字符串 映射为 哈希表上的索引，这就是哈希函数。

映射完成后，就可以 **通过查询索引下标** 快速确定是否存在 某个字符串 了。

如名称所示，肯定用到了哈希算法，即摘要算法。因为 哈希表上的索引不会直接存 字符串，而是存的字符串的哈希值。

具体参考noteforCV。

## 常见的哈希结构

数组、set、map。

set不是key-value的，只能放值。

map是key-value的。

哈希法是**牺牲了空间换取了时间**，因为我们要使用额外的 数组、set、map 来存放数据，才能实现快速的查找。

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

# 跳表

# 栈

# 队列

# 树

# 堆

# 图